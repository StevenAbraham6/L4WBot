{"version":3,"sources":["service-catalogs.js"],"names":["ServiceCatalogs","hosts","filter","removing","find","host","includes","active","catalog","catalogs","Array","isArray","map","catalogId","mapCatalogName","id","type","SERVICE_CATALOGS_ENUM_TYPES","STRING","length","cluster","clusters","local","priority","reduce","filteredHosts","currentHost","foundHost","hostGroup","push","foundHostCatalogPriority","NUMBER","currentHostCatalogPriority","splice","indexOf","service","services","filterActive","filterCatalog","filterCluster","filterLocal","filterPriority","filterService","validHosts","loadableHost","ServiceHost","hostReference","url","SERVICE_CATALOGS","undefined","hostCatalog","serviceLinks","catalogIndex","Error","output","key","defaultUri","split","uri"],"mappings":"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","file":"service-catalogs.js","sourcesContent":["import {\n  SERVICE_CATALOGS,\n  SERVICE_CATALOGS_ENUM_TYPES\n} from './constants';\nimport ServiceHost from './service-host';\n\n/**\n * The parameter transfer object for {@link ServiceCatalogs#mapRemoteCatalog}.\n * This object is shaped to match the object returned from the **U2C** service.\n *\n * @typedef {Record<string, string>} RSL\n * @typedef {Record<string, Array<Record<string, number | string>>>} RHC\n *\n * @typedef {Object} MapRemoteCatalogPTO\n * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.\n * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.\n * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.\n */\n\n/**\n * Service manipulation filter object for retrieving services within the\n * {@link ServiceCatalogs} class.\n *\n * @typedef {Object} HostFilter\n * @property {boolean} [HostFilter.active] - Active state to filter.\n * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.\n * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.\n * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.\n * @property {boolean} [HostFilter.priority] - Filter for the highest priority.\n * @property {Array<string | string} [HostFilter.service] - Services to filter.\n */\n\n/**\n * @class\n * @classdesc - Manages a collection of {@link ServiceHost} class objects.\n */\nexport default class ServiceCatalogs {\n  /**\n   * Generate a new {@link ServiceHost}.\n   *\n   * @public\n   * @constructor\n   * @memberof ServiceHost\n   */\n  constructor() {\n    /**\n     * The collection of managed {@link ServiceHost}s.\n     *\n     * @instance\n     * @type {Array<ServiceHost>}\n     * @private\n     * @memberof ServiceCatalogs\n     */\n    this.hosts = [];\n  }\n\n  /**\n   * An active, local, and priority mapped record of the current\n   * {@link ServiceCatalog#hosts}.\n   *\n   * @public\n   * @memberof ServiceCatalog\n   * @type {Record<string, string>}\n   */\n  get map() {\n    // Get a list of active, local, and priority-mapped hosts.\n    return this.find({\n      active: true,\n      local: true,\n      priority: true\n    }).reduce(\n      (map, host) => {\n        // Generate a new object to assign the existing map.\n        const hostReference = {};\n\n        // Assign the key:value pair for the service and url.\n        hostReference[host.service] = host.url;\n\n        // Assign the reference to the map and return.\n        return {...map, ...hostReference};\n      }, {}\n    );\n  }\n\n  /**\n   * Removes a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceCatalogs#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceCatalogs\n   * @param {HostFilter} filter - The inclusive filter for hosts to remove.\n   * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.\n   */\n  clear(filter) {\n    // Collect a list of hosts to remove based on the provided filter.\n    const removing = this.find(filter);\n\n    // Remove the hosts from the array.\n    this.hosts = this.hosts.filter(\n      (host) => !removing.includes(host)\n    );\n\n    // Return the removed hosts.\n    return removing;\n  }\n\n  /**\n   * Filter the {@link ServiceCatalogs#hosts} array against their active states.\n   *\n   * @private\n   * @memberof ServiceCatalogs\n   * @param {boolean} [active] - Filter for the host state.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterActive(active) {\n    // Filter the host array if the active requirement is true.\n    return (typeof active === 'boolean') ?\n      this.hosts.filter((host) => host.active === active) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceCatalogs#hosts} array against their assigned\n   * catalog values.\n   *\n   * @private\n   * @memberof ServiceCatalogs\n   * @param {Array<string> | string} [catalog] - Catalogs to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCatalog(catalog = []) {\n    // Generate a catalog names array based on the provided catalog param.\n    const catalogs = (Array.isArray(catalog) ? catalog : [catalog])\n      .map((catalogId) => ServiceCatalogs.mapCatalogName({\n        id: catalogId,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      }) || catalogId);\n\n    // Filter the host array against the catalog names array.\n    return (catalogs.length > 0) ?\n      this.hosts.filter((host) => catalogs.includes(host.catalog)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceCatalogs#hosts} array against their assigned\n   * cluster values.\n   *\n   * @private\n   * @memberof ServiceCatalogs\n   * @param {Array<string> | string} [cluster] - Clusters to filter for.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCluster(cluster = []) {\n    // Generate an array of clusters regardless of parameter type.\n    const clusters = (Array.isArray(cluster) ? cluster : [cluster]);\n\n    // Filter the host array against the provided clusters.\n    return (clusters.length > 0) ?\n      this.hosts.filter((host) => clusters.includes(host.id)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceCatalogs#hosts} array against their location in\n   * reference to the authenticated user.\n   *\n   * @private\n   * @memberof ServiceCatalogs\n   * @param {boolean} [local] - Filter for the host location.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterLocal(local) {\n    return (typeof local === 'boolean') ?\n      this.hosts.filter((host) => host.local === local) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the `{@link ServiceCatalogs#hosts} array for the highest priority\n   * hosts for each specific service.\n   *\n   * @private\n   * @memberof ServiceCatalogs\n   * @param {boolean} [priority] - Filter for the highest priority\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterPriority(priority) {\n    return (priority) ?\n      this.hosts.reduce(\n        (filteredHosts, currentHost) => {\n          // Validate that the current host is not active.\n          if (!currentHost.active) {\n            return filteredHosts;\n          }\n\n          // Determine if the filtered hosts array contains a host from the same\n          // host group.\n          const foundHost = filteredHosts.find(\n            (host) => host.hostGroup === currentHost.hostGroup\n          );\n\n          // Validate if a host was found.\n          if (!foundHost) {\n            filteredHosts.push(currentHost);\n\n            return filteredHosts;\n          }\n\n          // Map the found host's catalog to its priority value.\n          const foundHostCatalogPriority = ServiceCatalogs.mapCatalogName({\n            id: foundHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Map the current host's catalog to its priority value.\n          const currentHostCatalogPriority = ServiceCatalogs.mapCatalogName({\n            id: currentHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Validate if the found host has a lower priority than the current\n          // host.\n          if (\n            foundHostCatalogPriority < currentHostCatalogPriority ||\n            foundHost.priority < currentHost.priority\n          ) {\n            filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));\n            filteredHosts.push(currentHost);\n          }\n\n          return filteredHosts;\n        }, []\n      ) : [...this.hosts];\n  }\n\n  /**\n   * Filter the `{@link ServiceCatalogs#hosts} array for a host with a specified\n   * set of service names.\n   *\n   * @private\n   * @memberof ServiceCatalogs\n   * @param {Array<string> | string} [service] - Services to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterService(service = []) {\n    // Generate an array of clusters regardless of parameter type.\n    const services = (Array.isArray(service) ? service : [service]);\n\n    // Filter the host array against the provided clusters.\n    return (services.length > 0) ?\n      this.hosts.filter((host) => service.includes(host.service)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Get an array of {@link ServiceHost}s based on a provided\n   * {@link HostFilter} from the {@link ServiceCatalogs#hosts} array.\n   *\n   * @public\n   * @memberof ServiceCatalogs\n   * @param {HostFilter} param - The inclusive filter for hosts to find.\n   * @returns {Array<ServiceHost>} - The filtered hosts.\n   */\n  find({\n    active,\n    catalog,\n    cluster,\n    local,\n    priority,\n    service\n  } = {}) {\n    return this.hosts.filter(\n      (host) => (\n        this.filterActive(active).includes(host) &&\n        this.filterCatalog(catalog).includes(host) &&\n        this.filterCluster(cluster).includes(host) &&\n        this.filterLocal(local).includes(host) &&\n        this.filterPriority(priority).includes(host) &&\n        this.filterService(service).includes(host)\n      )\n    );\n  }\n\n  /**\n   * Load a formatted array of {@link ServiceHost} constructor parameter\n   * transfer objects as instances of {@link ServiceHost} class objects to the\n   * {@link ServiceCatalogs#hosts} array.\n   *\n   * @public\n   * @memberof ServiceCatalogs\n   * @param {Array<ServiceHost.ConstructorPTO>} hosts\n   * @returns {this}\n   */\n  load(hosts = []) {\n    // Validate that the provided hosts are eligible to be loaded.\n    const validHosts = hosts.filter((host) => !!(\n      ServiceCatalogs.mapCatalogName({\n        id: host.catalog,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      })));\n\n    // Load the eligible hosts.\n    this.hosts.push(\n      ...validHosts.map((loadableHost) => new ServiceHost(loadableHost))\n    );\n\n    return this;\n  }\n\n  /**\n   * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated\n   * idenfier or value.\n   *\n   * @public\n   * @static\n   * @memberof ServiceCatalogs\n   * @param {Object} pto - The parameter transfer object.\n   * @property {string | number} pto.id - The identifier to convert in the enum.\n   * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.\n   * @returns {string|number} - The matching enum value or index.\n   */\n  static mapCatalogName({id, type}) {\n    // Validate that the id is a number.\n    if (typeof id === 'number') {\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS[id] !== undefined) ? id : undefined;\n      }\n\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS[id];\n      }\n    }\n\n    // Validate that the id is a string.\n    if (typeof id === 'string') {\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS.includes(id) ? id : undefined;\n      }\n\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS.includes(id)) ?\n          SERVICE_CATALOGS.indexOf(id) :\n          undefined;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate a formatted array based on the object received from the **U2C**\n   * service for usage in the {@link ServiceCatalogs#load} method.\n   *\n   * @public\n   * @static\n   * @memberof ServiceCatalogs\n   * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.\n   * @throws - If the target catalog does not exist.\n   * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}\n   */\n  static mapRemoteCatalog({catalog, hostCatalog, serviceLinks}) {\n    // Collect the service catalog name if needed.\n    const catalogIndex = ServiceCatalogs.mapCatalogName({\n      id: catalog,\n      type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n    });\n\n    // Validate that the target catalog exists.\n    if (!SERVICE_CATALOGS.includes(catalogIndex)) {\n      throw new Error(`service-catalogs: '${catalog}' is not a valid catalog`);\n    }\n\n    // Map the remote catalog to a mountable host array.\n    return Object.keys(hostCatalog).reduce((output, key) => {\n      output.push(\n        ...hostCatalog[key].map((host) => ({\n          catalog: catalogIndex,\n          defaultUri: serviceLinks[host.id.split(':')[3]],\n          hostGroup: key,\n          id: host.id,\n          priority: host.priority,\n          uri: host.host\n        }))\n      );\n\n      return output;\n    }, []);\n  }\n}\n"]}