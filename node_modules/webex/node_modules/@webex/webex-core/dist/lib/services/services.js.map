{"version":3,"sources":["services.js"],"names":["Services","WebexPlugin","extend","namespace","props","validateDomains","_catalogs","_getCatalog","get","webex","name","priorityHost","serviceGroup","catalog","hasService","serviceName","hasAllowedDomains","getAllowedDomains","length","list","markFailedUrl","url","noPriorityHosts","updateServices","from","query","token","formattedQuery","status","collecting","waitForCatalog","queryKey","includes","reject","Error","base64","encode","email","_fetchNewServiceHostmap","then","serviceHostMap","updateServiceUrls","updateCredentialsConfig","catch","error","validateUser","reqId","logger","info","canAuthorize","credentials","getUserToken","sendUserActivation","toString","userObj","activated","exists","details","user","config","client_id","client_secret","collectPreauthCatalog","idbrokerService","getClientToken","uri","scope","tokenObj","collectSigninCatalog","rto","all","request","service","resource","method","headers","accept","authorization","undefined","body","shouldRefreshAccessToken","mode","idbroker","identity","setConfig","slice","timeout","postauth","waitForService","priorityUrl","priorityUrlObj","getServiceFromUrl","resolve","groupsToCheck","checkCatalog","catalogGroup","scopedPriorityUrl","scopedPrioriryUrlObj","map","group","_formatReceivedHostmap","serviceHostmap","formattedHostmap","hostCatalog","reduce","accumulator","key","id","split","defaultUrl","serviceLinks","serviceItem","find","item","defaultHost","Url","parse","hostname","hosts","push","host","ttl","priority","homeCluster","forEach","getClusterId","findClusterId","getServiceFromClusterId","params","findServiceFromClusterId","findServiceUrlFromUrl","isServiceUrl","isAllowedDomainUrl","findAllowedDomain","convertUrlToPriorityHostUrl","data","replace","qs","format","requestObject","initialize","ServiceCatalog","set","listenToOnce","services","discovery","formattedDiscoveryServices","allowedDomains","setAllowedDomains","warn"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;;AAEA;;;;AAEA;;;;;;AAEA;AACA;;;AAGA,IAAMA,WAAWC,sBAAYC,MAAZ,CAAmB;AAClCC,aAAW,UADuB;;AAGlCC,SAAO;AACLC,qBAAiB,CAAC,SAAD,EAAY,KAAZ,EAAmB,IAAnB;AADZ,GAH2B;;AAOlCC,aAAW,uBAPuB;;AASlC;;;;;;AAMAC,aAfkC,yBAepB;AACZ,WAAO,KAAKD,SAAL,CAAeE,GAAf,CAAmB,KAAKC,KAAxB,CAAP;AACD,GAjBiC;;;AAmBlC;;;;;;;;AAQAD,KA3BkC,eA2B9BE,IA3B8B,EA2BxBC,YA3BwB,EA2BVC,YA3BU,EA2BI;AACpC,QAAMC,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAOM,QAAQL,GAAR,CAAYE,IAAZ,EAAkBC,YAAlB,EAAgCC,YAAhC,CAAP;AACD,GA/BiC;;;AAiClC;;;;;;AAMAE,YAvCkC,sBAuCvBC,WAvCuB,EAuCV;AACtB,WAAO,CAAC,CAAE,KAAKP,GAAL,CAASO,WAAT,CAAV;AACD,GAzCiC;;;AA2ClC;;;;;AAKAC,mBAhDkC,+BAgDd;AAClB,QAAMH,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAQM,QAAQI,iBAAR,GAA4BC,MAA5B,GAAqC,CAA7C;AACD,GApDiC;;;AAsDlC;;;;;;;AAOAC,MA7DkC,gBA6D7BR,YA7D6B,EA6DfC,YA7De,EA6DD;AAC/B,QAAMC,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAOM,QAAQM,IAAR,CAAaR,YAAb,EAA2BC,YAA3B,CAAP;AACD,GAjEiC;;;AAmElC;;;;;;;;;;;;;AAaAQ,eAhFkC,yBAgFpBC,GAhFoB,EAgFfC,eAhFe,EAgFE;AAClC,QAAMT,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAOM,QAAQO,aAAR,CAAsBC,GAAtB,EAA2BC,eAA3B,CAAP;AACD,GApFiC;;;AAsFlC;;;;;;;;;;;;;AAaAC,gBAnGkC,4BAmGQ;AAAA;;AAAA,mFAAJ,EAAI;AAAA,QAA1BC,IAA0B,QAA1BA,IAA0B;AAAA,QAApBC,KAAoB,QAApBA,KAAoB;AAAA,QAAbC,KAAa,QAAbA,KAAa;;AACxC,QAAMb,UAAU,KAAKN,WAAL,EAAhB;AACA,QAAIoB,uBAAJ;AAAA,QAAoBf,qBAApB;;AAEA;AACA,YAAQY,IAAR;AACE,WAAK,SAAL;AAAgBZ,uBAAe,SAAf,CAA0B;AAC1C,WAAK,QAAL;AAAeA,uBAAe,QAAf,CAAyB;AACxC;AAASA,uBAAe,UAAf,CAA2B;AAHtC;;AAMA;AACA,QAAIC,QAAQe,MAAR,CAAehB,YAAf,EAA6BiB,UAAjC,EAA6C;AAC3C,aAAO,KAAKC,cAAL,CAAoBlB,YAApB,CAAP;AACD;;AAEDC,YAAQe,MAAR,CAAehB,YAAf,EAA6BiB,UAA7B,GAA0C,IAA1C;;AAEA,QAAIjB,iBAAiB,SAArB,EAAgC;AAC9B,UAAMmB,WAAWN,SAAS,oBAAYA,KAAZ,EAAmB,CAAnB,CAA1B;;AAEA,UAAI,CAAC,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,EAA6B,MAA7B,EAAqCO,QAArC,CAA8CD,QAA9C,CAAL,EAA8D;AAC5D,eAAO,kBAAQE,MAAR,CAAe,IAAIC,KAAJ,CAAU,4DAAV,CAAf,CAAP;AACD;AACF;AACD;AACA,QAAItB,iBAAiB,SAAjB,IAA8BA,iBAAiB,QAAnD,EAA6D;AAC3D,UAAMmB,YAAW,oBAAYN,KAAZ,EAAmB,CAAnB,CAAjB;;AAEAE,uBAAiB,EAAjB;AACAA,qBAAeI,SAAf,IAA2BA,cAAa,OAAb,GACzBI,eAAOC,MAAP,CAAcX,MAAMY,KAApB,CADyB,GACIZ,MAAMM,SAAN,CAD/B;AAED;;AAED,WAAO,KAAKO,uBAAL,CAA6B;AAClCd,gBADkC;AAElCE,kBAFkC;AAGlCD,aAAOE;AAH2B,KAA7B,EAKJY,IALI,CAKC,UAACC,cAAD,EAAoB;AACxB3B,cAAQ4B,iBAAR,CAA0B7B,YAA1B,EAAwC4B,cAAxC;AACA,YAAKE,uBAAL;AACA7B,cAAQe,MAAR,CAAehB,YAAf,EAA6BiB,UAA7B,GAA0C,KAA1C;AACD,KATI,EAUJc,KAVI,CAUE,UAACC,KAAD,EAAW;AAChB/B,cAAQe,MAAR,CAAehB,YAAf,EAA6BiB,UAA7B,GAA0C,KAA1C;;AAEA,aAAO,kBAAQI,MAAR,CAAeW,KAAf,CAAP;AACD,KAdI,CAAP;AAeD,GApJiC;;;AAsJlC;;;;;;;AAOA;;;;;;;;;AASA;;;;;;;AAOAC,cA7KkC,+BA6KS;AAAA;;AAAA,QAA7BR,KAA6B,SAA7BA,KAA6B;AAAA,4BAAtBS,KAAsB;AAAA,QAAtBA,KAAsB,+BAAd,WAAc;;AACzC,SAAKC,MAAL,CAAYC,IAAZ,CAAiB,6BAAjB;;AAEA;AACA,QAAI,CAACX,KAAL,EAAY;AACV,aAAO,kBAAQJ,MAAR,CAAe,IAAIC,KAAJ,CAAU,qBAAV,CAAf,CAAP;AACD;;AAED;AARyC,QASlCe,YATkC,GASlB,KAAKxC,KAAL,CAAWyC,WATO,CASlCD,YATkC;;AAWzC;;AACA,QAAIA,YAAJ,EAAkB;AAChB,aAAO,KAAK1B,cAAL,GACJgB,IADI,CACC;AAAA,eAAM,OAAK9B,KAAL,CAAWyC,WAAX,CAAuBC,YAAvB,EAAN;AAAA,OADD,EAEJZ,IAFI,CAEC,UAACb,KAAD;AAAA,eAAW,OAAK0B,kBAAL,CAAwB;AACvCf,sBADuC;AAEvCS,sBAFuC;AAGvCpB,iBAAOA,MAAM2B,QAAN;AAHgC,SAAxB,CAAX;AAAA,OAFD,EAOJd,IAPI,CAOC,UAACe,OAAD;AAAA,eAAc;AAClBC,qBAAW,IADO;AAElBC,kBAAQ,IAFU;AAGlBC,mBAAS,qCAHS;AAIlBC,gBAAMJ;AAJY,SAAd;AAAA,OAPD,CAAP;AAaD;;AAED;AACA;AA7ByC,gCA8BN,KAAK7C,KAAL,CAAWyC,WAAX,CAAuBS,MA9BjB;AAAA,QA8BlCC,SA9BkC,yBA8BlCA,SA9BkC;AAAA,QA8BvBC,aA9BuB,yBA8BvBA,aA9BuB;;AAgCzC;;AACA,QAAI,CAACD,SAAD,IAAc,CAACC,aAAnB,EAAkC;AAChC,aAAO,kBAAQ5B,MAAR,CAAe,IAAIC,KAAJ,CACpB,iDADoB,CAAf,CAAP;AAGD;AACD;;AAEA;AACA,QAAIR,cAAJ;;AAEA;AACA,WAAO,KAAKoC,qBAAL,CAA2B,EAACzB,YAAD,EAA3B,EACJE,IADI,CACC,YAAM;AACV;AACA;AACA;AACA,UAAMwB,kBAAkB,OAAKvD,GAAL,CAAS,UAAT,EAAqB,IAArB,CAAxB;;AAEA;AACA,aAAO,OAAKC,KAAL,CAAWyC,WAAX,CAAuBc,cAAvB,CAAsC;AAC3CC,aAAQF,eAAR,+BAD2C;AAE3CG,eAAO;AAFoC,OAAtC,CAAP;AAID,KAZI,EAaJ3B,IAbI,CAaC,UAAC4B,QAAD,EAAc;AAClB;AACAzC,cAAQyC,SAASd,QAAT,EAAR;;AAEA;AACA,aAAO,OAAKe,oBAAL,CAA0B,EAAC/B,YAAD,EAAQX,YAAR,EAA1B,CAAP;AACD,KAnBI;AAoBL;AACA;AArBK,KAsBJiB,KAtBI,CAsBE,UAACC,KAAD;AAAA,aAAY;AACjBY,gBAASZ,MAAMlC,IAAN,KAAe,UADP;AAEjB6C,mBAAW,KAFM;AAGjBE,iBAAUb,MAAMlC,IAAN,KAAe,UAAhB,GACP,kCADO,GAEP;AALe,OAAZ;AAAA,KAtBF;AA6BL;AACA;AA9BK,KA+BJ6B,IA/BI,CA+BC,UAAC8B,GAAD;AAAA,aAAS,kBAAQC,GAAR,CAAY,CACzBD,OAAO;AACLd,mBAAW,IADN;AAELC,gBAAQ,IAFH;AAGLC,iBAAS;AAHJ,OADkB,EAMzB,OAAKL,kBAAL,CAAwB,EAACf,YAAD,EAAQS,YAAR,EAAepB,YAAf,EAAxB,CANyB,CAAZ,CAAT;AAAA,KA/BD,EAuCJa,IAvCI,CAuCC;AAAA;AAAA,UAAE8B,GAAF;AAAA,UAAOX,IAAP;;AAAA,wCAAsBW,GAAtB,IAA2BX,UAA3B;AAAA,KAvCD,CAAP;AAwCD,GAjQiC;;;AAmQlC;;;;;;;;AAQA;;;;;;AAMAN,oBAjRkC,qCAiRQ;AAAA,QAAtBf,KAAsB,SAAtBA,KAAsB;AAAA,QAAfS,KAAe,SAAfA,KAAe;AAAA,QAARpB,KAAQ,SAARA,KAAQ;;AACxC,SAAKqB,MAAL,CAAYC,IAAZ,CAAiB,2CAAjB;;AAEA;AACA,WAAO,KAAKuB,OAAL,CAAa;AAClBC,eAAS,OADS;AAElBC,gBAAU,mBAFQ;AAGlBC,cAAQ,MAHU;AAIlBC,eAAS;AACPC,gBAAQ,kBADD;AAEPC,uBAAenD,KAFR;AAGP,6BAAqBoD;AAHd,OAJS;AASlBC,YAAM,EAAC1C,YAAD,EAAQS,YAAR,EATY;AAUlBkC,gCAA0B;AAVR,KAAb;AAYL;AAZK,KAaJzC,IAbI,CAaC;AAAA,UAAEwC,IAAF,SAAEA,IAAF;AAAA,aAAYA,IAAZ;AAAA,KAbD;AAcL;AAdK,KAeJpC,KAfI,CAeE;AAAA,aAAO,EAAP;AAAA,KAfF,CAAP;AAgBD,GArSiC;;;AAuSlC;;;;;;AAMAmB,uBA7SkC,mCA6SE;AAAA,oFAAJ,EAAI;AAAA,QAAbzB,KAAa,SAAbA,KAAa;;AAClC,QAAI,CAACA,KAAL,EAAY;AACV,aAAO,KAAKd,cAAL,CAAoB,EAACC,MAAM,SAAP,EAAkBC,OAAO,EAACwD,MAAM,sBAAP,EAAzB,EAApB,CAAP;AACD;;AAED,WAAO,KAAK1D,cAAL,CAAoB,EAACC,MAAM,SAAP,EAAkBC,OAAO,EAACY,YAAD,EAAzB,EAApB,CAAP;AACD,GAnTiC;;;AAqTlC;;;;;;;AAOA+B,sBA5TkC,kCA4TQ;AAAA,oFAAJ,EAAI;AAAA,QAApB/B,KAAoB,SAApBA,KAAoB;AAAA,QAAbX,KAAa,SAAbA,KAAa;;AACxC,QAAI,CAACW,KAAL,EAAY;AACV,aAAO,kBAAQJ,MAAR,CAAe,IAAIC,KAAJ,CAAU,qBAAV,CAAf,CAAP;AACD;AACD,QAAI,CAACR,KAAL,EAAY;AACV,aAAO,kBAAQO,MAAR,CAAe,IAAIC,KAAJ,CAAU,qBAAV,CAAf,CAAP;AACD;;AAED,WAAO,KAAKX,cAAL,CAAoB,EAACC,MAAM,QAAP,EAAiBC,OAAO,EAACY,YAAD,EAAxB,EAAiCX,YAAjC,EAApB,CAAP;AACD,GArUiC;;;AAuUlC;;;;;AAKAgB,yBA5UkC,qCA4UR;AAAA,gBACK,KAAKvB,IAAL,CAAU,IAAV,CADL;AAAA,QACjB+D,QADiB,SACjBA,QADiB;AAAA,QACPC,QADO,SACPA,QADO;;AAGxB,QAAID,YAAYC,QAAhB,EAA0B;AACxB,WAAK1E,KAAL,CAAW2E,SAAX,CAAqB;AACnBlC,qBAAa;AACXgC,oBAAU;AACR7D,iBAAK6D,SAASG,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CADG,CACmB;AADnB,WADC;AAIXF,oBAAU;AACR9D,iBAAK8D,SAASE,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CADG,CACmB;AADnB;AAJC;AADM,OAArB;AAUD;AACF,GA3ViC;;;AA6VlC;;;;;;;AAOAvD,gBApWkC,0BAoWnBlB,YApWmB,EAoWL0E,OApWK,EAoWI;AACpC,QAAMzE,UAAU,KAAKN,WAAL,EAAhB;;AAEA,QAAIK,iBAAiB,UAAjB,IACF,KAAKH,KAAL,CAAWyC,WAAX,CAAuBD,YADrB,IAEF,CAACpC,QAAQe,MAAR,CAAe2D,QAAf,CAAwB1D,UAF3B,EAGE;AACA,aAAO,KAAKN,cAAL,EAAP;AACD;;AAED,WAAOV,QAAQiB,cAAR,CAAuBlB,YAAvB,EAAqC0E,OAArC,CAAP;AACD,GA/WiC;;;AAiXlC;;;;;;;;;AASA;;;;;;;AAOAE,gBAjYkC,iCAiYO;AAAA;;AAAA,QAAzB9E,IAAyB,SAAzBA,IAAyB;AAAA,8BAAnB4E,OAAmB;AAAA,QAAnBA,OAAmB,iCAAT,CAAS;AAAA,QAANjE,GAAM,SAANA,GAAM;;AACvC,QAAMoE,cAAc,KAAKjF,GAAL,CAASE,IAAT,EAAe,IAAf,CAApB;AACA,QAAMgF,iBAAiB,KAAKC,iBAAL,CAAuBtE,GAAvB,CAAvB;;AAEA,QAAIoE,eAAeC,cAAnB,EAAmC;AACjC,aAAO,kBAAQE,OAAR,CAAgBH,eAAeC,eAAeD,WAA9C,CAAP;AACD;;AAED,QAAM5E,UAAU,KAAKN,WAAL,EAAhB;AACA,QAAMsF,gBAAgB,CAAC,SAAD,EAAY,QAAZ,EAAsB,UAAtB,CAAtB;;AAEA,WAAO,sBAAY,UAACD,OAAD,EAAU3D,MAAV,EAAqB;AACtC,UAAM6D,eAAe,SAAfA,YAAe,CAACC,YAAD;AAAA,eACnBlF,QAAQiB,cAAR,CAAuBiE,YAAvB,EAAqCT,OAArC,EACG/C,IADH,CACQ,YAAM;AACV,cAAMyD,oBAAoB,OAAKxF,GAAL,CAASE,IAAT,EAAe,IAAf,CAA1B;AACA,cAAMuF,uBAAuB,OAAKN,iBAAL,CAAuBtE,GAAvB,CAA7B;;AAEA,cAAI2E,qBAAqBC,oBAAzB,EAA+C;AAC7CL,oBAAQI,qBAAqBC,qBAAqBR,WAAlD;AACD;AACF,SARH,EASG9C,KATH,CASS;AAAA,iBAAMmC,SAAN;AAAA,SATT,CADmB;AAAA,OAArB;;AAYA,wBAAQR,GAAR,CAAYuB,cAAcK,GAAd,CAAkB,UAACC,KAAD;AAAA,eAAWL,aAAaK,KAAb,CAAX;AAAA,OAAlB,CAAZ,EACG5D,IADH,CACQ,YAAM;AACVN,eAAO,IAAIC,KAAJ,0BACiBxB,IADjB,oCAAP;AAGD,OALH;AAMD,KAnBM,CAAP;AAoBD,GAhaiC;;;AAkalC;;;;;;;AAOA0F,wBAzakC,kCAyaXC,cAzaW,EAyaK;AACrC;AACA,QAAMC,mBAAmB,oBAAYD,eAAeE,WAA3B,EAAwCC,MAAxC,CACvB,UAACC,WAAD,EAAcC,GAAd,EAAsB;AAAA;;AACpB,UAAIL,eAAeE,WAAf,CAA2BG,GAA3B,EAAgCxF,MAAhC,KAA2C,CAA/C,EAAkD;AAChD,eAAOuF,WAAP;AACD;;AAED,UAAM1F,cAAcsF,eAAeE,WAAf,CAA2BG,GAA3B,EAAgC,CAAhC,EAAmCC,EAAnC,CAAsCC,KAAtC,CAA4C,GAA5C,EAAiD,CAAjD,CAApB;AACA,UAAMC,aAAaR,eAAeS,YAAf,CAA4B/F,WAA5B,CAAnB;;AAEA,UAAIgG,cAAcN,YAAYO,IAAZ,CAChB,UAACC,IAAD;AAAA,eAAUA,KAAKvG,IAAL,KAAcK,WAAxB;AAAA,OADgB,CAAlB;;AAIA,UAAI,CAACgG,WAAL,EAAkB;AAChBA,sBAAc;AACZrG,gBAAMK,WADM;AAEZ8F,gCAFY;AAGZK,uBAAaC,cAAIC,KAAJ,CAAUP,UAAV,EAAsBQ,QAHvB;AAIZC,iBAAO;AAJK,SAAd;;AAOAb,oBAAYc,IAAZ,CAAiBR,WAAjB;AACD;;AAED,wCAAYO,KAAZ,EAAkBC,IAAlB;AACE;AACA;AACEC,cAAMd,GADR;AAEEe,aAAK,CAAC,CAFR;AAGEC,kBAAU,EAHZ;AAIEf,YAAIN,eAAeE,WAAf,CAA2BG,GAA3B,EAAgC,CAAhC,EAAmCC,EAJzC;AAKEgB,qBAAaZ,YAAYG,WAAZ,KAA4BR;AAL3C,OAFF,0CAUKL,eAAeE,WAAf,CAA2BG,GAA3B,EAAgCR,GAAhC,CACD,UAACsB,IAAD;AAAA,0CACKA,IADL;AAEEG,uBAAaZ,YAAYG,WAAZ,KAA4BR;AAF3C;AAAA,OADC,CAVL;;AAkBA,aAAOD,WAAP;AACD,KA3CsB,EA2CpB,EA3CoB,CAAzB;;AA8CA;AACA,wBAAYJ,eAAeS,YAA3B,EAAyCc,OAAzC,CAAiD,UAAClB,GAAD,EAAS;AACxD,UAAMlC,UAAU8B,iBAAiBU,IAAjB,CAAsB,UAACC,IAAD;AAAA,eAAUA,KAAKvG,IAAL,KAAcgG,GAAxB;AAAA,OAAtB,CAAhB;;AAEA,UAAI,CAAClC,OAAL,EAAc;AACZ8B,yBAAiBiB,IAAjB,CAAsB;AACpB7G,gBAAMgG,GADc;AAEpBG,sBAAYR,eAAeS,YAAf,CAA4BJ,GAA5B,CAFQ;AAGpBQ,uBAAaC,cAAIC,KAAJ,CAAUf,eAAeS,YAAf,CAA4BJ,GAA5B,CAAV,EAA4CW,QAHrC;AAIpBC,iBAAO;AAJa,SAAtB;AAMD;AACF,KAXD;;AAaA,WAAOhB,gBAAP;AACD,GAxeiC;;;AA0elC;;;;;AAKAuB,cA/ekC,wBA+erBxG,GA/eqB,EA+ehB;AAChB,QAAMR,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAOM,QAAQiH,aAAR,CAAsBzG,GAAtB,CAAP;AACD,GAnfiC;;;AAqflC;;;;;;;;;;;AAWA0G,yBAhgBkC,mCAggBVC,MAhgBU,EAggBF;AAC9B,QAAMnH,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAOM,QAAQoH,wBAAR,CAAiCD,MAAjC,CAAP;AACD,GApgBiC;;;AAsgBlC;;;;;;;;;;AAUArC,mBAhhBkC,+BAghBN;AAAA,QAAVtE,GAAU,uEAAJ,EAAI;;AAC1B,QAAMmD,UAAU,KAAKjE,WAAL,GAAmB2H,qBAAnB,CAAyC7G,GAAzC,CAAhB;;AAEA,QAAI,CAACmD,OAAL,EAAc;AACZ,aAAOM,SAAP;AACD;;AAED,WAAO;AACLpE,YAAM8D,QAAQ9D,IADT;AAEL+E,mBAAajB,QAAQhE,GAAR,CAAY,IAAZ,CAFR;AAGLqG,kBAAYrC,QAAQhE,GAAR;AAHP,KAAP;AAKD,GA5hBiC;;;AA8hBlC;;;;;;AAMA2H,cApiBkC,wBAoiBrB9G,GApiBqB,EAoiBhB;AAChB,QAAMR,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAO,CAAC,CAAEM,QAAQqH,qBAAR,CAA8B7G,GAA9B,CAAV;AACD,GAxiBiC;;;AA0iBlC;;;;;;AAMA+G,oBAhjBkC,8BAgjBf/G,GAhjBe,EAgjBV;AACtB,QAAMR,UAAU,KAAKN,WAAL,EAAhB;;AAEA,WAAO,CAAC,CAAEM,QAAQwH,iBAAR,CAA0BhH,GAA1B,CAAV;AACD,GApjBiC;;;AAsjBlC;;;;;;;;AAQAiH,6BA9jBkC,yCA8jBI;AAAA,QAAVjH,GAAU,uEAAJ,EAAI;;AACpC,QAAMkH,OAAO,KAAK5C,iBAAL,CAAuBtE,GAAvB,CAAb;;AAEA,QAAI,CAACkH,IAAL,EAAW;AACT,YAAMrG,4CAA0Cb,GAA1C,OAAN;AACD;;AAED,WAAOA,IAAImH,OAAJ,CAAYD,KAAK1B,UAAjB,EAA6B0B,KAAK9C,WAAlC,CAAP;AACD,GAtkBiC;;;AAwkBlC;;;;;;;;;;;;;AAaAnD,yBArlBkC,qCAqlBiB;AAAA;;AAAA,qFAAJ,EAAI;AAAA,QAA1Bd,IAA0B,UAA1BA,IAA0B;AAAA,QAApBC,KAAoB,UAApBA,KAAoB;AAAA,QAAbC,KAAa,UAAbA,KAAa;;AACjD,QAAM8C,UAAU,KAAhB;AACA,QAAMC,WAAWjD,aAAWA,IAAX,gBAA4B,UAA7C;AACA,QAAMiH,gCAAShH,KAAT,IAAgBiH,QAAQ,SAAxB,GAAN;;AAEA,QAAMC,gBAAgB;AACpBjE,cAAQ,KADY,EACLF,gBADK,EACIC,kBADJ,EACcgE;AADd,KAAtB;;AAIA,QAAI/G,KAAJ,EAAW;AACTiH,oBAAchE,OAAd,GAAwB,EAACE,eAAenD,KAAhB,EAAxB;AACD;;AAED,WAAO,KAAK6C,OAAL,CAAaoE,aAAb,EACJpG,IADI,CACC;AAAA,UAAEwC,IAAF,UAAEA,IAAF;AAAA,aAAY,OAAKqB,sBAAL,CAA4BrB,IAA5B,CAAZ;AAAA,KADD,CAAP;AAED,GApmBiC;;;AAsmBlC;;;;;;;AAOA6D,YA7mBkC,wBA6mBrB;AAAA;;AACX,QAAM/H,UAAU,IAAIgI,wBAAJ,EAAhB;;AAEA,SAAKvI,SAAL,CAAewI,GAAf,CAAmB,KAAKrI,KAAxB,EAA+BI,OAA/B;;AAEA;AACA,SAAKkI,YAAL,CAAkB,KAAKtI,KAAvB,EAA8B,eAA9B,EAA+C,YAAM;AACnD;AADmD,UAE5CuI,QAF4C,GAEhC,OAAKvI,KAAL,CAAWkD,MAFqB,CAE5CqF,QAF4C;;AAInD;;AACA,UAAIA,QAAJ,EAAc;AACZ;AACA,YAAIA,SAASC,SAAb,EAAwB;AACtB;AACA,cAAMC,6BAA6B,oBAAYF,SAASC,SAArB,EAChC/C,GADgC,CAC5B,UAACQ,GAAD;AAAA,mBAAU;AACbhG,oBAAMgG,GADO;AAEbG,0BAAYmC,SAASC,SAAT,CAAmBvC,GAAnB;AAFC,aAAV;AAAA,WAD4B,CAAnC;;AAMA;AACA7F,kBAAQ4B,iBAAR,CAA0B,WAA1B,EAAuCyG,0BAAvC;AACD;;AAED;AACA,YAAIF,SAASG,cAAb,EAA6B;AAC3B;AACAtI,kBAAQuI,iBAAR,CAA0BJ,SAASG,cAAnC;AACD;;AAED;AACA,eAAK9I,eAAL,GAAuB2I,SAAS3I,eAAhC;AACD;AACF,KA5BD;;AA8BA;AACA;AACA,SAAK0I,YAAL,CAAkB,KAAKtI,KAAvB,EAA8B,OAA9B,EAAuC,YAAM;AAC3C;AACA,UAAI,OAAKA,KAAL,CAAWyC,WAAX,CAAuBD,YAA3B,EAAyC;AACvC,eAAK1B,cAAL;AACA;AACA;AAFA,SAGGoB,KAHH,CAII;AAAA,iBAAM,OAAKI,MAAL,CAAYsG,IAAZ,CAAiB,2CAAjB,CAAN;AAAA,SAJJ;AAMD,OAPD,MAQK;AACH,eAAKvF,qBAAL,CAA2B,EAACzB,OAAO,OAAK5B,KAAL,CAAWkD,MAAX,CAAkBtB,KAA1B,EAA3B;AACD;AACF,KAbD;AAcD,GAjqBiC;AAAA;AAAA,CAAnB,CAAjB;AAmqBA;;kBAEerC,Q","file":"services.js","sourcesContent":["import Url from 'url';\n\nimport {base64} from '@webex/common';\n\nimport WebexPlugin from '../webex-plugin';\n\nimport ServiceCatalog from './service-catalog';\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  props: {\n    validateDomains: ['boolean', false, true]\n  },\n\n  _catalogs: new WeakMap(),\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if the catalog contains a specific service\n   *\n   * @param {string} serviceName - The service name to validate.\n   * @returns {boolean} - True if the service exists.\n   */\n  hasService(serviceName) {\n    return !!(this.get(serviceName));\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains() {\n    const catalog = this._getCatalog();\n\n    return (catalog.getAllowedDomains().length > 0);\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({from, query, token} = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery, serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited': serviceGroup = 'preauth'; break;\n      case 'signin': serviceGroup = 'signin'; break;\n      default: serviceGroup = 'postauth'; break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      const queryKey = query && Object.keys(query)[0];\n\n      if (!['email', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return Promise.reject(new Error('a query param of email, userId, orgId, or mode is required'));\n      }\n    }\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n      formattedQuery[queryKey] = queryKey === 'email' ?\n        base64.encode(query.email) : query[queryKey];\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceUrls(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **Atlas** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser({email, reqId = 'WEBCLIENT'}) {\n    this.logger.info('services: validating a user');\n\n    // Validate that an email parameter key was provided.\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    // Destructure the credentials object.\n    const {canAuthorize} = this.webex.credentials;\n\n    // Validate that the user is already authorized.\n    if (canAuthorize) {\n      return this.updateServices()\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) => this.sendUserActivation({\n          email,\n          reqId,\n          token: token.toString()\n        }))\n        .then((userObj) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj\n        }));\n    }\n\n    // Destructure the client authorization details.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    // Validate that client authentication details exist.\n    if (!client_id || !client_secret) {\n      return Promise.reject(new Error(\n        'client authentication details are not available'\n      ));\n    }\n    /* eslint-enable camelcase */\n\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n    let token;\n\n    // Begin client authentication user validation.\n    return this.collectPreauthCatalog({email})\n      .then(() => {\n        // Retrieve the service url from the updated catalog. This is required\n        // since `WebexCore` is usually not fully initialized at the time this\n        // request completes.\n        const idbrokerService = this.get('idbroker', true);\n\n        // Collect the client auth token.\n        return this.webex.credentials.getClientToken({\n          uri: `${idbrokerService}idb/oauth2/v1/access_token`,\n          scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'\n        });\n      })\n      .then((tokenObj) => {\n        // Generate the token string.\n        token = tokenObj.toString();\n\n        // Collect the signin catalog using the client auth information.\n        return this.collectSigninCatalog({email, token});\n      })\n      // Validate if collecting the signin catalog failed and populate the RTO\n      // with the appropriate content.\n      .catch((error) => ({\n        exists: (error.name !== 'NotFound'),\n        activated: false,\n        details: (error.name !== 'NotFound') ?\n          'user exists but is not activated' :\n          'user does not exist and is not activated'\n      }))\n      // Validate if the previous promise resolved with an RTO and populate the\n      // new RTO accordingly.\n      .then((rto) => Promise.all([\n        rto || {\n          activated: true,\n          exists: true,\n          details: 'user exists and is activated'\n        },\n        this.sendUserActivation({email, reqId, token})\n      ]))\n      .then(([rto, user]) => ({...rto, user}));\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {AtlasDTO} - The DTO returned from the **Atlas** service.\n   */\n  sendUserActivation({email, reqId, token}) {\n    this.logger.info('services: sending user activation request');\n\n    // Send the user activation request to the **Atlas** service.\n    return this.request({\n      service: 'atlas',\n      resource: 'users/activations',\n      method: 'POST',\n      headers: {\n        accept: 'application/json',\n        authorization: token,\n        'x-prelogin-userid': undefined\n      },\n      body: {email, reqId},\n      shouldRefreshAccessToken: false\n    })\n      // On success, return the **Atlas** user object.\n      .then(({body}) => body)\n      // On failure, return an empty user object.\n      .catch(() => ({}));\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog({email} = {}) {\n    if (!email) {\n      return this.updateServices({from: 'limited', query: {mode: 'DEFAULT_BY_PROXIMITY'}});\n    }\n\n    return this.updateServices({from: 'limited', query: {email}});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({from: 'signin', query: {email}, token});\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.slice(0, -1) // remove trailing slash\n          },\n          identity: {\n            url: identity.slice(0, -1) // remove trailing slash\n          }\n        }\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n\n    if (serviceGroup === 'postauth' &&\n      this.webex.credentials.canAuthorize &&\n      !catalog.status.postauth.collecting\n    ) {\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService({name, timeout = 5, url}) {\n    const priorityUrl = this.get(name, true);\n    const priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return Promise.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    const catalog = this._getCatalog();\n    const groupsToCheck = ['limited', 'signin', 'postauth'];\n\n    return new Promise((resolve, reject) => {\n      const checkCatalog = (catalogGroup) =>\n        catalog.waitForCatalog(catalogGroup, timeout)\n          .then(() => {\n            const scopedPriorityUrl = this.get(name, true);\n            const scopedPrioriryUrlObj = this.getServiceFromUrl(url);\n\n            if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n              resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n            }\n          })\n          .catch(() => undefined);\n\n      Promise.all(groupsToCheck.map((group) => checkCatalog(group)))\n        .then(() => {\n          reject(new Error(\n            `services: service '${name}' was not found after waiting`\n          ));\n        });\n    });\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * catalog endpoint.\n   * @param {object} serviceHostmap\n   * @returns {object}\n   */\n  _formatReceivedHostmap(serviceHostmap) {\n    // map the host catalog items to a formatted hostmap\n    const formattedHostmap = Object.keys(serviceHostmap.hostCatalog).reduce(\n      (accumulator, key) => {\n        if (serviceHostmap.hostCatalog[key].length === 0) {\n          return accumulator;\n        }\n\n        const serviceName = serviceHostmap.hostCatalog[key][0].id.split(':')[3];\n        const defaultUrl = serviceHostmap.serviceLinks[serviceName];\n\n        let serviceItem = accumulator.find(\n          (item) => item.name === serviceName\n        );\n\n        if (!serviceItem) {\n          serviceItem = {\n            name: serviceName,\n            defaultUrl,\n            defaultHost: Url.parse(defaultUrl).hostname,\n            hosts: []\n          };\n\n          accumulator.push(serviceItem);\n        }\n\n        serviceItem.hosts.push(\n          // map the default key as a low priority default for cluster matching\n          {\n            host: key,\n            ttl: -1,\n            priority: 10,\n            id: serviceHostmap.hostCatalog[key][0].id,\n            homeCluster: serviceItem.defaultHost === key\n          },\n          // map the rest of the hosts in their proper locations\n          ...serviceHostmap.hostCatalog[key].map(\n            (host) => ({\n              ...host,\n              homeCluster: serviceItem.defaultHost === key\n            })\n          )\n        );\n\n        return accumulator;\n      }, []\n    );\n\n    // append service links that do not exist in the host catalog\n    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {\n      const service = formattedHostmap.find((item) => item.name === key);\n\n      if (!service) {\n        formattedHostmap.push({\n          name: key,\n          defaultUrl: serviceHostmap.serviceLinks[key],\n          defaultHost: Url.parse(serviceHostmap.serviceLinks[key]).hostname,\n          hosts: []\n        });\n      }\n    });\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl(url = '') {\n    const service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get()\n    };\n  },\n\n  /**\n   * Verify that a provided url exists in the service\n   * catalog.\n   * @param {string} url\n   * @returns {boolean} - true if exists, false otherwise\n   */\n  isServiceUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findServiceUrlFromUrl(url));\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!(catalog.findAllowedDomain(url));\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl(url = '') {\n    const data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(`No service associated with url: [${url}]`);\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({from, query, token} = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...query, format: 'hostmap'};\n\n    const requestObject = {\n      method: 'GET', service, resource, qs\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.request(requestObject)\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n\n    this._catalogs.set(this.webex, catalog);\n\n    // Listen for configuration changes once.\n    this.listenToOnce(this.webex, 'change:config', () => {\n      // Destructure the configuration object for the services plugin.\n      const {services} = this.webex.config;\n\n      // Validate that the services configuration exists.\n      if (services) {\n        // Check for discovery services.\n        if (services.discovery) {\n          // Format the discovery configuration into an injectable array.\n          const formattedDiscoveryServices = Object.keys(services.discovery)\n            .map((key) => ({\n              name: key,\n              defaultUrl: services.discovery[key]\n            }));\n\n          // Inject formatted services into services catalog.\n          catalog.updateServiceUrls('discovery', formattedDiscoveryServices);\n        }\n\n        // Check for allowed host domains.\n        if (services.allowedDomains) {\n          // Store the allowed domains as a property of the catalog.\n          catalog.setAllowedDomains(services.allowedDomains);\n        }\n\n        // Set `validateDomains` property to match configuration\n        this.validateDomains = services.validateDomains;\n      }\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      /* eslint-disable camelcase */\n      if (this.webex.credentials.canAuthorize) {\n        this.updateServices()\n        // this catch prevents crashing in unique situations found\n        // primarily in unit testing with the karma suite.\n          .catch(\n            () => this.logger.warn('services: catalog retrieval failed w/auth')\n          );\n      }\n      else {\n        this.collectPreauthCatalog({email: this.webex.config.email});\n      }\n    });\n  }\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"]}